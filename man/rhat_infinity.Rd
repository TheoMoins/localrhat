% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/infinity_rhat.R
\name{rhat_infinity}
\alias{rhat_infinity}
\title{Scalar version of the local Gelman Rubin diagnostic \eqn{\hat{R}(x)}.}
\usage{
rhat_infinity(chains, dir = NULL, max_nb_points = 500)
}
\arguments{
\item{chains}{an array of size \eqn{n \times m} in the univariate case and of
size \eqn{n \times d \times m} in the d-variate one, where \eqn{n} is the length of
the chains, \eqn{m \geq 2} is the number of chains and \eqn{d} is the dimension.}

\item{dir}{a vector specifying which indicator to use for the multivariate case.
See the function \code{multivariate_directed_local_rhat} for more details. If no
direction is given, the computation is done on the indicator variable with the
"\eqn{\leq}" sign on all dimension.}

\item{max_nb_points}{the maximal length of the grid in the case where the total
number of samples is larger. By default, \code{max_nb_points = 500}.}
}
\value{
The value of \eqn{\hat{R}_\infty} computed on the \eqn{m} chains.
}
\description{
Compute \eqn{\hat{R}_\infty}, a scalar summary of the function \eqn{\hat{R}(x)}
corresponding to the supremum over the quantiles \eqn{x}.
}
\details{
\eqn{\hat{R}_\infty} is based on \eqn{\hat{R}(x)}, the computation of
\eqn{\hat{R}} on \eqn{I(\theta^{(i,j)} \leq x)} (in the univariate case):
\deqn{R_\infty = \sup_{x \in R} R(x).}
This require to compute \eqn{\hat{R}(x)} on different values of \eqn{x} to
estimate this supremum. See the function \code{all_local_rhat} for more details.
In the multivariate case, \eqn{\hat{R}} can be computed on
\eqn{I\{\theta_1^{(j)} \leq x_1, \ldots, \theta_d^{(j)} \leq x_d\}},
but also with indicator where some "\eqn{\leq} are replaced by "\eqn{\geq}",
which leads to \eqn{2^{d-1}} possibilities and potentially as many different
results of \eqn{\hat{R}_\infty}. Here, a 0-1 vector can be given in the function
to specify which indicator to use.
}
\examples{
library(localrhat)
library("MASS") # For Multivariate Normal Distribution
rho <- 0.9
m <- 4
n <- 100
reps <- 50

# Function to generate bivariate normal chains, with one that differs by its sigma:
gen_bvnormal_chains <- function(M, N, rho){
    sig_matrix <- (1-rho) * diag(2) + matrix(rho, nrow=2, ncol=2)
    return (array(c(mvrnorm((M-1)*N, mu = rep(0, 2), Sigma = diag(2)),
                    mvrnorm(N, mu = rep(0, 2), Sigma = sig_matrix)), c(N,2,M)))
}

R_values <- c()
for (e in 1:reps){
    chains <- gen_bvnormal_chains(m, n, rho)
    # R_values <- c(R_values, rhat_infinity_max_directions(chains))
}
# R_mat <- matrix(data = R_values, ncol = 1)
# colnames(R_mat) <- "R-hat-inf_max_dir"

# plot_hist(R_mat, bin_size = 0.004,
#           lim_y_axis = 15, vaxis_pos = 1.015,
#           plot_threshold = F)

}
\references{
TO INCLUDE
}
